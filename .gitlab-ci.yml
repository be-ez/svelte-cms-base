image: node:current-alpine

stages:
  - test
  - release
  - build
  - deploy
  - rebuild

variables:
  APP_NAME: personal

# Auto-cancel redundant pipelines
workflow:
  auto_cancel:
    on_new_commit: interruptible

test:
  stage: test
  variables:
    # Dummy env vars for svelte-check - not used in actual tests
    DIRECTUS_API_URL: 'https://dummy.example.com'
    DIRECTUS_TOKEN: 'dummy-token'
  script:
    - corepack enable
    - pnpm install
    - pnpm run lint:fix
    - pnpm run check
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

release:
  stage: release
  image: node:22-alpine
  variables:
    GIT_DEPTH: 0
    GITLAB_TOKEN: $GITLAB_RELEASE_TOKEN
    GL_TOKEN: $GITLAB_RELEASE_TOKEN
  before_script:
    - apk add --no-cache git
    - corepack enable
    - pnpm install
    # Configure git for commits
    - git config --global user.email "ci@gitlab.com"
    - git config --global user.name "GitLab CI"
  script:
    - npx semantic-release
    - |
      VERSION=$(node -p "require('./package.json').version")
      echo "VERSION=$VERSION" >> release.env
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  artifacts:
    reports:
      dotenv: release.env

build-complete:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
  dependencies:
    - release
  interruptible: true
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Load version from release job
    - if [ -f release.env ]; then source release.env; fi
    - echo "Building version ${VERSION:-latest}"
  script:
    # Build x86_64-only complete build (images + static site) and push
    - |
      docker build \
        --platform linux/amd64 \
        --target complete-build \
        --build-arg DIRECTUS_API_URL=$DIRECTUS_API_URL \
        --build-arg DIRECTUS_TOKEN=$DIRECTUS_TOKEN \
        --tag $CI_REGISTRY_IMAGE:complete-build-$CI_COMMIT_SHA \
        --tag $CI_REGISTRY_IMAGE:complete-build-latest \
        --tag $CI_REGISTRY_IMAGE:complete-build-${VERSION:-latest} \
        .
    - docker push $CI_REGISTRY_IMAGE:complete-build-$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:complete-build-latest
    - if [ ! -z "$VERSION" ]; then docker push $CI_REGISTRY_IMAGE:complete-build-$VERSION; fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

build-docker:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
  dependencies:
    - release
    - build-complete
  interruptible: true
  before_script:
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    
    # Load version from release job
    - if [ -f release.env ]; then source release.env; fi
    - echo "Building version ${VERSION:-latest}"

    # Set up Docker Buildx for multi-platform builds
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
    - docker buildx create --name mybuilder --driver docker-container --bootstrap
    - docker buildx use mybuilder
    - docker buildx inspect --bootstrap
  script:
    # Build and push multi-arch nginx using complete build
    - |
      docker buildx build \
        --platform linux/amd64,linux/arm64 \
        --build-context complete-build=docker-image://$CI_REGISTRY_IMAGE:complete-build-$CI_COMMIT_SHA \
        --build-arg CLOUDFLARE_TOKEN=$CLOUDFLARE_TOKEN \
        --build-arg CLOUDFLARE_ZONE_ID=$CLOUDFLARE_ZONE_ID \
        --cache-from type=registry,ref=$CI_REGISTRY_IMAGE:cache \
        --cache-to type=registry,ref=$CI_REGISTRY_IMAGE:cache,mode=max \
        --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA \
        --tag $CI_REGISTRY_IMAGE:latest \
        --tag $CI_REGISTRY_IMAGE:${VERSION:-latest} \
        --push \
        .
  only:
    - main

deploy-coolify:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    # Trigger Coolify deployment via API
    - |
      curl -X GET \
        -H "Authorization: Bearer $COOLIFY_API_KEY" \
        "$COOLIFY_API_URL"
  only:
    - main
#   before_script:
#     - apk update
#     - apk add openssh-client git
#     - eval $(ssh-agent -s)
#     - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#     - mkdir -p ~/.ssh
#     - chmod 700 ~/.ssh
#     - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
#     - chmod 644 ~/.ssh/known_hosts
#   script:
#     - if git remote | grep dokku; then git remote remove dokku; fi
#     - git remote add dokku dokku@$DOKKU_HOST:personal
#     - git config --global core.sshCommand "ssh -o StrictHostKeyChecking=no"
#     - git push dokku HEAD:main
#   only:
#     - main

# dokku-rebuild:
#   stage: rebuild
#   before_script:
#     - apk update
#     - apk add openssh-client
#     - eval $(ssh-agent -s)
#     - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#     - mkdir -p ~/.ssh
#     - chmod 700 ~/.ssh
#     - echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
#     - chmod 644 ~/.ssh/known_hosts
#   script:
#     - ssh -o StrictHostKeyChecking=no dokku@100.91.27.125 dokku ps:rebuild personal
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "trigger"
#       when: always
